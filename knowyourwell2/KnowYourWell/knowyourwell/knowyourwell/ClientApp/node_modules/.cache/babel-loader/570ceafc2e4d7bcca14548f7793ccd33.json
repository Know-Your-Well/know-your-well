{"ast":null,"code":"import e from \"axios\";\nimport t from \"js-cookie\";\nconst r = {\n  user: {},\n  tokens: {},\n  mode: \"live\"\n};\n\nfunction n(e) {\n  try {\n    const t = e.split(\".\")[1].replace(\"-\", \"+\").replace(\"_\", \"/\");\n    return JSON.parse(atob(t));\n  } catch (e) {\n    console.error(\"Problem decoding JWT payload\", e);\n  }\n}\n\nfunction o(e) {\n  try {\n    if (!e) return !1;\n    const t = n(e);\n    return new Date(1e3 * t.exp) > new Date();\n  } catch (e) {\n    return !1;\n  }\n}\n\nfunction i(e) {\n  if (e) {\n    if (\"string\" == typeof e) throw new Error(e);\n    if (e?.response?.data?.message) throw new Error(e.response.data.message);\n    throw e;\n  }\n}\n\nconst s = r.user;\n\nfunction a(e) {\n  return e.replace(/([^:]\\/)\\/+/g, \"$1\");\n}\n\nconst c = function (t, n, o) {\n  try {\n    const i = a(`${r.baseUrl}${t}`);\n    return Promise.resolve(e.put(i, n, o));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n},\n      u = function (t, n, o) {\n  try {\n    const i = a(`${r.baseUrl}${t}`);\n    return Promise.resolve(e.post(i, n, o));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n},\n      d = function (t, n) {\n  try {\n    const o = a(`${r.baseUrl}${t}`);\n    return Promise.resolve(e.get(o, n));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nfunction h(e, n, o) {\n  const i = `${o}.${r.tenantId}`;\n  n = n || {\n    secure: \"live\" === r.mode,\n    sameSite: \"Lax\"\n  }, \"refresh\" === o && (n.sameSite = \"Strict\"), t.set(i, e, n);\n}\n\nfunction l(e) {\n  let r, n;\n\n  try {\n    const e = window.location.pathname,\n          t = window.location.hostname,\n          o = t.split(\".\").slice(-2).join(\".\");\n    r = [void 0, e, \"/\"], n = [void 0, t, `.${t}`, o, `.${o}`];\n  } catch (e) {\n    r = [void 0, \"/\"], n = [void 0];\n  }\n\n  r.map(r => {\n    n.map(n => {\n      const o = {};\n      n && (o.domain = n), r && (o.path = r), t.remove(e, o);\n    });\n  });\n}\n\nfunction f() {\n  l(r.tokens.accessTokenName), l(r.tokens.idTokenName), l(r.tokens.refreshTokenName), r.tokens.accessToken = void 0, r.tokens.idToken = void 0, r.tokens.refreshToken = void 0, function () {\n    for (const e in r.user) \"function\" != typeof r.user[e] && delete r.user[e];\n  }();\n}\n\nfunction m(e) {\n  h(e.access.value, e.access.cookieOptions, \"access\"), h(e.id.value, e.id.cookieOptions, \"id\"), e.refresh && e.refresh.value && h(e.refresh.value, e.refresh.cookieOptions, \"refresh\"), k();\n}\n\nfunction w(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n\n  return r && r.then ? r.then(void 0, t) : r;\n}\n\nconst p = function (_ref) {\n  let {} = _ref;\n  return Promise.resolve();\n},\n      v = function () {\n  try {\n    const e = w(function () {\n      return Promise.resolve(function () {\n        try {\n          const e = t.get(r.tokens.refreshTokenName);\n          return Promise.resolve(w(function () {\n            return Promise.resolve(d(\"/auth/refresh\", {\n              headers: {\n                authorization: `Bearer ${e}`\n              }\n            })).then(function (_ref2) {\n              let {\n                data: e,\n                status: t\n              } = _ref2;\n              if (200 !== t) throw new Error(e.message || \"Problem with request\");\n              if (e.tokens) return m(e.tokens), e;\n              throw new Error(\"Problem setting cookies\");\n            });\n          }, function (e) {\n            i(e);\n          }));\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }()).then(function () {});\n    }, function (e) {\n      console.warn(`Refresh failed: ${e.message}`);\n    });\n    return Promise.resolve(e && e.then ? e.then(function () {}) : void 0);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nfunction k() {\n  [\"access\", \"id\", \"refresh\"].map(e => {\n    try {\n      const o = t.get(r.tokens[`${e}TokenName`]);\n      r.tokens[`${e}Token`] = o, \"id\" === e && o && function () {\n        if (!r.tokens.idToken) return console.warn(\"Cannot define user: missing ID token\");\n        r.user = r.user || {};\n        const e = n(r.tokens.idToken),\n              t = [\"email\", \"phoneNumber\", \"username\", \"name\", \"image\", \"data\", \"confirmedAt\", \"createdAt\", \"updatedAt\", \"mode\", \"userId\", \"userUuid\", \"tenantId\", \"isConfirmed\"];\n\n        for (const n of t) {\n          if (\"update\" === n) return;\n          r.user[n] = e[n];\n        }\n      }();\n    } catch (t) {\n      console.warn(`Problem setting ${e} token.`);\n    }\n  });\n}\n\nfunction P() {\n  return o(r.tokens.accessToken);\n}\n\nr.tokens = r.tokens || {}, r.tokens.refresh = v;\n\nconst g = r.tokens,\n      y = function () {\n  try {\n    return Promise.resolve(I()).then(function (e) {\n      return {\n        isLoggedIn: e\n      };\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n},\n      I = function () {\n  return Promise.resolve(function (e, t) {\n    try {\n      var n = !!P() || !!o(r.tokens.refreshToken) && Promise.resolve(v()).then(function () {\n        return P();\n      });\n    } catch (e) {\n      return !1;\n    }\n\n    return n && n.then ? n.then(void 0, function () {\n      return !1;\n    }) : n;\n  }());\n};\n\nfunction b(e) {\n  if (\"object\" == typeof window && \"object\" == typeof window.location && window.location.href && !(window.location.href.indexOf(`${e}=`) < 0)) return decodeURIComponent(window.location.href.split(`${e}=`)[1].split(\"&\")[0]);\n}\n\nconst T = _ref3 => {\n  let {\n    redirect: e,\n    data: t\n  } = _ref3;\n  !1 !== e && $(e || b(\"redirect\") || t.redirectTo || \"/\");\n};\n\nfunction $(e) {\n  if (!e || \"object\" != typeof document || \"object\" != typeof window) return;\n\n  try {\n    document && window;\n  } catch (e) {\n    return;\n  }\n\n  const t = document.createElement(\"a\");\n  t.href = e, t.pathname !== window.location.pathname && window.location.assign(`${t.pathname}${t.hash}${t.search}`);\n}\n\nfunction E(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n\n  return r && r.then ? r.then(void 0, t) : r;\n}\n\nconst j = function (_ref4) {\n  let {\n    password: e,\n    existingPassword: t\n  } = _ref4;\n\n  try {\n    return Promise.resolve(E(function () {\n      if (!r.tokens.accessToken) throw new Error('updatePassword({ method: \"jwt\" }) was called without a JWT access token.');\n      return Promise.resolve(c(\"/auth/basic\", {\n        tenantId: r.tenantId,\n        password: e,\n        existingPassword: t\n      }, {\n        headers: {\n          Authorization: `Bearer ${r.tokens.accessToken}`\n        }\n      })).then(function (_ref5) {\n        let {\n          data: e\n        } = _ref5;\n        return e;\n      });\n    }, function (e) {\n      i(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n},\n      U = function (_ref6) {\n  let {\n    uuid: e,\n    token: t,\n    password: n,\n    redirect: o\n  } = _ref6;\n\n  try {\n    return Promise.resolve(E(function () {\n      if (t = t || b(\"token\"), e = e || b(\"uuid\"), !t || !e) throw new Error(\"Missing token or uuid\");\n      return Promise.resolve(c(\"/auth/reset\", {\n        tenantId: r.tenantId,\n        uuid: e,\n        token: t,\n        password: n\n      })).then(function (_ref7) {\n        let {\n          data: e\n        } = _ref7;\n        if (e.tokens) return m(e.tokens), T({\n          redirect: o,\n          data: e\n        }), e;\n        throw new Error(\"There was a problem resetting your password. Please try again.\");\n      });\n    }, function (e) {\n      i(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n},\n      N = function (_ref8) {\n  let {\n    method: e,\n    password: t,\n    existingPassword: n,\n    uuid: o,\n    token: i,\n    redirect: s\n  } = _ref8;\n\n  try {\n    switch (e) {\n      case \"link\":\n        return U({\n          uuid: o,\n          token: i,\n          password: t,\n          redirect: s\n        });\n\n      case \"jwt\":\n        return j({\n          password: t,\n          existingPassword: n\n        });\n\n      default:\n        if (i = i || b(\"token\"), (o = o || b(\"uuid\")) && i) return U({\n          uuid: o,\n          token: i,\n          password: t,\n          redirect: s\n        });\n        if (r.tokens.accessToken) return j({\n          password: t,\n          existingPassword: n\n        });\n        throw new Error(\"updatePassword() was called without link credentials (token & uuid) or a JWT access token.\");\n    }\n  } catch (e) {\n    return Promise.reject(e);\n  }\n},\n      C = N;\n\nfunction O(_ref9) {\n  let {\n    provider: e,\n    redirect: t\n  } = _ref9;\n  if (!e) throw new Error(\"Missing provider\");\n\n  const n = function (_ref10) {\n    let {\n      provider: e,\n      redirect: t\n    } = _ref10;\n    if (!e) throw new Error(\"Missing provider\");\n    if (!r.tenantId) throw new Error(\"Missing tenantId\");\n    let n = `${r.baseUrl}auth/${e}/login?tenant_id=${r.tenantId}&origin=${window.location.origin}`,\n        o = t || b(\"redirect\");\n    return !1 === t && (o = \"object\" == typeof document && document.location.pathname), o && (n += `&redirect=${encodeURIComponent(o)}`), n;\n  }({\n    provider: e,\n    redirect: t\n  });\n\n  window.location.assign(n);\n}\n\nfunction x(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n\n  return r && r.then ? r.then(void 0, t) : r;\n}\n\nconst z = function (_ref11) {\n  let {\n    email: e,\n    name: t,\n    username: n,\n    userData: o,\n    options: s\n  } = _ref11;\n\n  try {\n    return Promise.resolve(x(function () {\n      return Promise.resolve(u(\"/auth/link\", {\n        email: e,\n        name: t,\n        username: n,\n        data: o,\n        options: s,\n        tenantId: r.tenantId\n      })).then(function (_ref12) {\n        let {\n          data: e\n        } = _ref12;\n        return e;\n      });\n    }, function (e) {\n      i(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nfunction L(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n\n  return r && r.then ? r.then(void 0, t) : r;\n}\n\nfunction S(_ref13) {\n  let {\n    channel: e,\n    phoneNumber: t,\n    email: r\n  } = _ref13;\n  if (\"sms\" !== e && \"email\" !== e) throw new Error(\"Invalid channel\");\n  if (\"sms\" === e && !t) throw new Error('SMS verification code requires \"phoneNumber\"');\n  if (\"email\" === e && !r) throw new Error('Email verification code requires \"email\"');\n}\n\nconst M = function (_ref14) {\n  let {\n    channel: e = \"sms\",\n    phoneNumber: t,\n    email: n,\n    name: o,\n    username: s,\n    data: a\n  } = _ref14;\n\n  try {\n    return Promise.resolve(L(function () {\n      return S({\n        channel: e,\n        phoneNumber: t,\n        email: n\n      }), Promise.resolve(u(\"/auth/code\", {\n        channel: e,\n        email: n,\n        phoneNumber: t,\n        name: o,\n        username: s,\n        data: a,\n        tenantId: r.tenantId\n      })).then(function (_ref15) {\n        let {\n          data: e\n        } = _ref15;\n        return e;\n      });\n    }, function (e) {\n      i(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nfunction B(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n\n  return r && r.then ? r.then(void 0, t) : r;\n}\n\nfunction D(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n\n  return r && r.then ? r.then(void 0, t) : r;\n}\n\nconst R = /((^127\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.))\\d{1,3}\\.\\d{1,3}/g,\n      A = function () {\n  try {\n    const e = function (e, t) {\n      try {\n        var n = Promise.resolve(d(`/tenants/${r.tenantId}/mode`)).then(function (_ref16) {\n          let {\n            data: e\n          } = _ref16;\n          J.value = e.mode || \"test\", J.reason = q(J.value), r.mode = J.value;\n        });\n      } catch (e) {\n        return t();\n      }\n\n      return n && n.then ? n.then(void 0, t) : n;\n    }(0, function () {\n      J.value = \"test\", r.mode = J.value;\n    });\n\n    return Promise.resolve(e && e.then ? e.then(function () {}) : void 0);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n},\n      J = {\n  value: \"live\",\n  reason: void 0,\n  setMode: A\n};\n\nfunction W() {\n  const e = function (e) {\n    try {\n      const e = window.location.hostname;\n      return !(!e.match(/localhost/g) && !e.match(R));\n    } catch (e) {\n      return !0;\n    }\n  }() || !function () {\n    try {\n      return \"https:\" === window.location.protocol;\n    } catch (e) {\n      return !1;\n    }\n  }() ? \"test\" : \"live\";\n  J.value = e, J.reason = q(e), r.mode = e;\n}\n\nfunction q(e) {\n  try {\n    return \"live\" === e ? \"domain\" : \"http:\" === window.location.protocol ? \"http\" : \"https:\" !== window.location.protocol ? \"protocol\" : \"domain\";\n  } catch (e) {}\n}\n\nW(), r.user.update = function (e) {\n  try {\n    return !e || Object.keys(e).length < 1 ? Promise.resolve(console.warn(\"Missing user properties to update\")) : Promise.resolve(c(\"/self\", e, {\n      headers: {\n        authorization: `Bearer ${r.tokens.accessToken}`\n      }\n    })).then(function () {\n      return Promise.resolve(v()).then(function () {\n        return r.user;\n      });\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}, r.user.hasRole = function (e) {\n  let {\n    tenantId: t\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  try {\n    if (!r.tokens.accessToken || !r.tenantId) return !1;\n    const {\n      authorization: o\n    } = n(r.tokens.accessToken);\n    return !!o && !(!o[t = t || r.tenantId] || !o[t].roles) && o[t].roles.indexOf(e) > -1;\n  } catch (e) {\n    return !1;\n  }\n}, r.user.updatePassword = N, r.user.getTotp = function () {\n  try {\n    return Promise.resolve(B(function () {\n      if (!r.tokens.accessToken) throw new Error(\"getTotp() was called without a JWT access token.\");\n      return Promise.resolve(d(\"/auth/totp\", {\n        headers: {\n          Authorization: `Bearer ${r.tokens.accessToken}`\n        }\n      })).then(function (_ref17) {\n        let {\n          data: e\n        } = _ref17;\n        return e;\n      });\n    }, function (e) {\n      i(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nlet F = [],\n    _ = !1;\n\nvar V = {\n  addInitCallback: function (e) {\n    e && \"function\" == typeof e && F.push(e);\n  },\n  init: function (t) {\n    let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!t) return console.warn(\"Userfront initialized without tenantId\");\n\n    if (r.tenantId = t, r.baseUrl = n.baseUrl || \"https://api.userfront.com/v0/\", r.baseUrl.endsWith(\"/\") || (r.baseUrl += \"/\"), n.domain) {\n      r.domain = n.domain;\n      const t = `https://${r.domain}`;\n      e.defaults.headers.common[\"x-application-id\"] = t, e.defaults.headers.common[\"x-origin\"] = t;\n    }\n\n    r.tokens = r.tokens || {}, r.tokens.accessTokenName = `access.${r.tenantId}`, r.tokens.idTokenName = `id.${r.tenantId}`, r.tokens.refreshTokenName = `refresh.${r.tenantId}`, k(), W();\n\n    try {\n      F.length > 0 && F.forEach(e => {\n        e && \"function\" == typeof e && e({\n          tenantId: t\n        });\n      }), F = [];\n    } catch (e) {}\n  },\n  registerUrlChangedEventListener: function () {\n    if (!_) {\n      _ = !0;\n\n      try {\n        history.pushState = (e = history.pushState, function () {\n          var t = e.apply(this, arguments);\n          return window.dispatchEvent(new Event(\"pushstate\")), window.dispatchEvent(new Event(\"urlchanged\")), t;\n        }), history.replaceState = (e => function () {\n          var t = e.apply(this, arguments);\n          return window.dispatchEvent(new Event(\"replacestate\")), window.dispatchEvent(new Event(\"urlchanged\")), t;\n        })(history.replaceState), window.addEventListener(\"popstate\", () => {\n          window.dispatchEvent(new Event(\"urlchanged\"));\n        });\n      } catch (e) {}\n\n      var e;\n    }\n  },\n  logout: function () {\n    let {\n      method: e,\n      redirect: t\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      if (\"saml\" === e) return function () {\n        try {\n          if (!r.tokens.accessToken) throw new Error(\"Please log in to authorize your logout request.\");\n          const e = D(function () {\n            return Promise.resolve(d(\"/auth/saml/idp/token\", {\n              headers: {\n                authorization: `Bearer ${r.tokens.accessToken}`\n              }\n            })).then(function (_ref18) {\n              let {\n                data: e\n              } = _ref18;\n              window.location.assign(`${r.baseUrl}auth/saml/idp/logout?tenant_id=${r.tenantId}&token=${e.token}&uuid=${r.user.userUuid}`);\n            });\n          }, function (e) {\n            i(e);\n          });\n          return Promise.resolve(e && e.then ? e.then(function () {}) : void 0);\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }();\n      if (!r.tokens.accessToken) return Promise.resolve(f());\n      const n = D(function () {\n        return Promise.resolve(d(\"/auth/logout\", {\n          headers: {\n            authorization: `Bearer ${r.tokens.accessToken}`\n          }\n        })).then(function (_ref19) {\n          let {\n            data: e\n          } = _ref19;\n          f(), T({\n            redirect: t,\n            data: e\n          });\n        });\n      }, function () {\n        f();\n      });\n      return Promise.resolve(n && n.then ? n.then(function () {}) : void 0);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  mode: J,\n  setMode: A,\n  refresh: (e, t, r) => {\n    try {\n      console.warn(\"Userfront.refresh() is deprecated and will be removed. Please use Userfront.tokens.refresh() instead.\");\n    } catch (e) {}\n\n    return v();\n  },\n  login: function () {\n    let {\n      method: e,\n      userId: t,\n      userUuid: n,\n      email: o,\n      username: s,\n      emailOrUsername: a,\n      phoneNumber: h,\n      password: l,\n      token: f,\n      uuid: w,\n      totpCode: v,\n      backupCode: k,\n      channel: P,\n      verificationCode: g,\n      redirect: y\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      if (!e) throw new Error('Userfront.login called without \"method\" property.');\n\n      switch (e) {\n        case \"apple\":\n        case \"azure\":\n        case \"facebook\":\n        case \"github\":\n        case \"google\":\n        case \"linkedin\":\n          return Promise.resolve(O({\n            provider: e,\n            redirect: y\n          }));\n\n        case \"password\":\n          return Promise.resolve(function (_ref20) {\n            let {\n              email: e,\n              username: t,\n              emailOrUsername: n,\n              password: o,\n              redirect: s\n            } = _ref20;\n\n            try {\n              return Promise.resolve(E(function () {\n                return Promise.resolve(u(\"/auth/basic\", {\n                  tenantId: r.tenantId,\n                  emailOrUsername: e || t || n,\n                  password: o\n                })).then(function (_ref21) {\n                  let {\n                    data: e\n                  } = _ref21;\n                  let t;\n\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorCode\")) return e;\n                    throw new Error(\"Please try again.\");\n                  }\n\n                  const n = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return m(e.tokens), Promise.resolve(p(e)).then(function () {\n                      return T({\n                        redirect: s,\n                        data: e\n                      }), t = 1, e;\n                    });\n                  }();\n\n                  return n && n.then ? n.then(r) : r(n);\n                });\n              }, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            email: o,\n            username: s,\n            emailOrUsername: a,\n            password: l,\n            redirect: y\n          }));\n\n        case \"passwordless\":\n          return Promise.resolve(z({\n            email: o\n          }));\n\n        case \"link\":\n          return Promise.resolve(function () {\n            let {\n              token: e,\n              uuid: t,\n              redirect: n\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            try {\n              return Promise.resolve(x(function () {\n                if (e = e || b(\"token\"), t = t || b(\"uuid\"), e && t) return Promise.resolve(c(\"/auth/link\", {\n                  token: e,\n                  uuid: t,\n                  tenantId: r.tenantId\n                })).then(function (_ref22) {\n                  let {\n                    data: e\n                  } = _ref22;\n                  let t;\n\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorCode\")) return e;\n                    throw new Error(\"Problem logging in.\");\n                  }\n\n                  const o = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return m(e.tokens), Promise.resolve(p(e)).then(function () {\n                      return T({\n                        redirect: n,\n                        data: e\n                      }), t = 1, e;\n                    });\n                  }();\n\n                  return o && o.then ? o.then(r) : r(o);\n                });\n              }, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            token: f,\n            uuid: w,\n            redirect: y\n          }));\n\n        case \"totp\":\n          return Promise.resolve(function () {\n            let {\n              totpCode: e,\n              backupCode: t,\n              userId: n,\n              userUuid: o,\n              emailOrUsername: s,\n              email: a,\n              username: c,\n              phoneNumber: d,\n              redirect: h\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            try {\n              return Promise.resolve(B(function () {\n                if (e || t) return Promise.resolve(u(\"/auth/totp\", {\n                  totpCode: e,\n                  backupCode: t,\n                  userId: n,\n                  userUuid: o,\n                  emailOrUsername: s,\n                  email: a,\n                  username: c,\n                  phoneNumber: d,\n                  tenantId: r.tenantId\n                })).then(function (_ref23) {\n                  let {\n                    data: e\n                  } = _ref23;\n                  let t;\n\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorCode\")) return e;\n                    throw new Error(\"Problem logging in.\");\n                  }\n\n                  const n = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return m(e.tokens), Promise.resolve(p(e)).then(function () {\n                      return T({\n                        redirect: h,\n                        data: e\n                      }), t = 1, e;\n                    });\n                  }();\n\n                  return n && n.then ? n.then(r) : r(n);\n                });\n              }, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            totpCode: v,\n            backupCode: k,\n            userId: t,\n            userUuid: n,\n            emailOrUsername: a,\n            email: o,\n            username: s,\n            phoneNumber: h,\n            redirect: y\n          }));\n\n        case \"verificationCode\":\n          return Promise.resolve(function () {\n            let {\n              channel: e,\n              verificationCode: t,\n              email: n,\n              phoneNumber: o,\n              redirect: s\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            try {\n              return Promise.resolve(L(function () {\n                return S({\n                  channel: e,\n                  phoneNumber: o,\n                  email: n\n                }), Promise.resolve(c(\"/auth/code\", {\n                  channel: e,\n                  verificationCode: t,\n                  email: n,\n                  phoneNumber: o,\n                  tenantId: r.tenantId\n                })).then(function (_ref24) {\n                  let {\n                    data: e\n                  } = _ref24;\n                  let t;\n\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorCode\")) return e;\n                    throw new Error(\"Problem logging in.\");\n                  }\n\n                  const n = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return m(e.tokens), Promise.resolve(p(e)).then(function () {\n                      return T({\n                        redirect: s,\n                        data: e\n                      }), t = 1, e;\n                    });\n                  }();\n\n                  return n && n.then ? n.then(r) : r(n);\n                });\n              }, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            channel: P,\n            email: o,\n            phoneNumber: h,\n            verificationCode: g,\n            redirect: y\n          }));\n\n        case \"saml\":\n          return Promise.resolve(function () {\n            try {\n              return Promise.resolve(function (e, t) {\n                try {\n                  var n = r.tokens.accessToken ? Promise.resolve(d(\"/auth/saml/idp/token\", {\n                    headers: {\n                      authorization: `Bearer ${r.tokens.accessToken}`\n                    }\n                  })).then(function (_ref25) {\n                    let {\n                      data: e\n                    } = _ref25;\n                    window.location.assign(`${r.baseUrl}auth/saml/idp/login?tenant_id=${r.tenantId}&token=${e.token}&uuid=${r.user.userUuid}`);\n                  }) : console.warn(\"Cannot complete SAML login without access token\");\n                } catch (e) {\n                  return t(e);\n                }\n\n                return n && n.then ? n.then(void 0, t) : n;\n              }(0, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }());\n\n        default:\n          throw new Error('Userfront.login called with invalid \"method\" property.');\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  resetPassword: C,\n  updatePassword: N,\n  sendLoginLink: function (e) {\n    try {\n      return Promise.resolve(x(function () {\n        return Promise.resolve(u(\"/auth/link\", {\n          email: e,\n          tenantId: r.tenantId\n        })).then(function (_ref26) {\n          let {\n            data: e\n          } = _ref26;\n          return e;\n        });\n      }, function (e) {\n        i(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  sendResetLink: function (e) {\n    try {\n      return Promise.resolve(E(function () {\n        return Promise.resolve(u(\"/auth/reset/link\", {\n          email: e,\n          tenantId: r.tenantId\n        })).then(function (_ref27) {\n          let {\n            data: e\n          } = _ref27;\n          return e;\n        });\n      }, function (e) {\n        i(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  sendVerificationCode: M,\n  signup: function () {\n    let {\n      method: e,\n      email: t,\n      username: n,\n      phoneNumber: o,\n      name: s,\n      data: a,\n      password: c,\n      channel: d,\n      redirect: h\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      if (!e) throw new Error('Userfront.signup called without \"method\" property.');\n\n      switch (e) {\n        case \"apple\":\n        case \"azure\":\n        case \"facebook\":\n        case \"github\":\n        case \"google\":\n        case \"linkedin\":\n          return Promise.resolve(O({\n            provider: e,\n            redirect: h\n          }));\n\n        case \"password\":\n          return Promise.resolve(function () {\n            let {\n              username: e,\n              name: t,\n              email: n,\n              password: o,\n              userData: s,\n              redirect: a\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            try {\n              return Promise.resolve(E(function () {\n                return Promise.resolve(u(\"/auth/create\", {\n                  tenantId: r.tenantId,\n                  username: e,\n                  name: t,\n                  email: n,\n                  password: o,\n                  data: s\n                })).then(function (_ref28) {\n                  let {\n                    data: e\n                  } = _ref28;\n                  if (e.tokens) return m(e.tokens), Promise.resolve(p(e)).then(function () {\n                    return T({\n                      redirect: a,\n                      data: e\n                    }), e;\n                  });\n                  throw new Error(\"Please try again.\");\n                });\n              }, function (e) {\n                i(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            username: n,\n            name: s,\n            email: t,\n            password: c,\n            userData: a,\n            redirect: h\n          }));\n\n        case \"passwordless\":\n          return Promise.resolve(z({\n            email: t,\n            name: s,\n            username: n,\n            userData: a\n          }));\n\n        case \"verificationCode\":\n          return Promise.resolve(M({\n            channel: d,\n            email: t,\n            phoneNumber: o,\n            name: s,\n            username: n,\n            data: a\n          }));\n\n        default:\n          throw new Error('Userfront.signup called with invalid \"method\" property.');\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  store: r,\n  tokens: g,\n  accessToken: function () {\n    return r.tokens.accessToken = t.get(r.tokens.accessTokenName), r.tokens.accessToken;\n  },\n  idToken: function () {\n    return r.tokens.idToken = t.get(r.tokens.idTokenName), r.tokens.idToken;\n  },\n  getSession: y,\n  redirectIfLoggedIn: function () {\n    let {\n      redirect: e\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      return Promise.resolve(y()).then(function (_ref29) {\n        let {\n          isLoggedIn: t\n        } = _ref29;\n        if (!t) return f();\n        if (e) return $(e);\n        if (b(\"redirect\")) return $(b(\"redirect\"));\n\n        const n = function (e, t) {\n          try {\n            var n = Promise.resolve(d(\"/self\", {\n              headers: {\n                authorization: `Bearer ${r.tokens.accessToken}`\n              }\n            })).then(function (_ref30) {\n              let {\n                data: e\n              } = _ref30;\n              e.tenant && e.tenant.loginRedirectPath && $(e.tenant.loginRedirectPath);\n            });\n          } catch (e) {\n            return t();\n          }\n\n          return n && n.then ? n.then(void 0, t) : n;\n        }(0, function () {\n          f();\n        });\n\n        return n && n.then ? n.then(function () {}) : void 0;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  redirectIfLoggedOut: function () {\n    let {\n      redirect: e\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      return Promise.resolve(y()).then(function (_ref31) {\n        let {\n          isLoggedIn: t\n        } = _ref31;\n        if (!t) return f(), e ? $(e) : b(\"redirect\") ? $(b(\"redirect\")) : void 0;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  user: s\n};\nexport { V as default };","map":{"version":3,"mappings":"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","names":["store","user","tokens","mode","getJwtPayload","token","split","replace","JSON","parse","atob","encodedPayload","error","console","isJwtLocallyValid","payload","Date","exp","Error","response","data","message","reduceSlashes","str","put","path","options","url","baseUrl","axios","post","e","get","setCookie","value","type","cookieName","tenantId","secure","sameSite","Cookies","set","name","domains","window","location","pathname","hostname","primaryDomain","slice","join","paths","undefined","err","map","domain","remove","removeCookie","accessTokenName","idTokenName","refreshTokenName","accessToken","idToken","refreshToken","attr","unsetUser","access","cookieOptions","id","refresh","setTokensFromCookies","body","recover","result","then","v","headers","authorization","status","setCookiesAndTokens","throwFormattedError","basicRefresh","_catch","warn","tokenName","setUser","idTokenPayload","propsToDefine","prop","isAccessTokenLocallyValid","getIsLoggedIn","Promise","isLoggedIn","n","getQueryAttr","attrName","href","indexOf","decodeURIComponent","handleRedirect","redirect","redirectToPath","redirectTo","pathOrUrl","document","createElement","el","assign","hash","search","updatePasswordWithJwt","existingPassword","password","Authorization","updatePasswordWithLink","uuid","updatePassword","method","resetPassword","signonWithSso","provider","getProviderLink","origin","encodeURIComponent","sendPasswordlessLink","email","username","userData","enforceChannel","channel","phoneNumber","res","privateIPRegex","setMode","reason","getReason","modeValue","isTestHostname","hn","match","protocol","isHttps","setModeSync","update","Object","keys","length","hasRole","roleName","roles","getTotp","initCallbacks","isRegistered","addInitCallback","cb","push","init","opts","endsWith","defaults","common","forEach","registerUrlChangedEventListener","history","pushState","f","ret","apply","this","arguments","dispatchEvent","Event","replaceState","addEventListener","logout","userUuid","completeSamlLogout","removeAllCookies","a","b","c","login","userId","emailOrUsername","totpCode","backupCode","verificationCode","resolve","hasOwnProperty","exchange","_exit","loginWithPassword","loginWithLink","loginWithTotp","loginWithVerificationCode","completeSamlLogin","sendLoginLink","sendResetLink","sendVerificationCode","signup","signupWithPassword","getSession","redirectIfLoggedIn","tenant","loginRedirectPath","redirectIfLoggedOut"],"sources":["C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\store.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\utils.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\user.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\api.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\cookies.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\tokens.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\refresh.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\session.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\url.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\password.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\sso.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\link.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\verificationCode.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\totp.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\logout.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\constants.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\mode.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\user.methods.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\index.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\login.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\saml.js","C:\\Users\\fahad\\Source\\newgit\\know-your-well\\knowyourwell2\\KnowYourWell\\knowyourwell\\knowyourwell\\ClientApp\\node_modules\\@userfront\\core\\src\\signup.js"],"sourcesContent":["export const store = {\n  user: {},\n  tokens: {},\n  mode: \"live\",\n};\n","/**\n * This file is for zero-dependency utilities that can\n * be imported by any other file. Don't add any imports\n * to this file other than constants\n */\n\n/**\n * Get the unverified base64 decoded payload of a JWT\n *\n * @param {String} token - JSON Web Token\n * @returns {Object}\n */\nexport function getJwtPayload(token) {\n  try {\n    const encodedPayload = token\n      .split(\".\")[1]\n      .replace(\"-\", \"+\")\n      .replace(\"_\", \"/\");\n    return JSON.parse(atob(encodedPayload));\n  } catch (error) {\n    console.error(\"Problem decoding JWT payload\", error);\n  }\n}\n\n/**\n * Client-side check:\n * Determine whether the given JWT is present and unexpired\n *\n * @param {String} token JSON Web Token\n * @returns {Boolean}\n */\nexport function isJwtLocallyValid(token) {\n  try {\n    // Must be present\n    if (!token) {\n      return false;\n    }\n\n    // Must not be expired\n    const payload = getJwtPayload(token);\n    return new Date(payload.exp * 1000) > new Date();\n  } catch (error) {\n    return false;\n  }\n}\n\nexport function throwFormattedError(error) {\n  if (!error) return;\n  if (typeof error === \"string\") throw new Error(error);\n  if (error?.response?.data?.message) {\n    throw new Error(error.response.data.message);\n  }\n  throw error;\n}\n","import { store } from \"./store.js\";\nimport { getJwtPayload } from \"./utils.js\";\n\n/**\n * Define the store.user object based on the ID token\n */\nexport function setUser() {\n  if (!store.tokens.idToken) {\n    return console.warn(\"Cannot define user: missing ID token\");\n  }\n\n  store.user = store.user || {};\n  const idTokenPayload = getJwtPayload(store.tokens.idToken);\n\n  // Set basic user information properties from ID token\n  const propsToDefine = [\n    \"email\",\n    \"phoneNumber\",\n    \"username\",\n    \"name\",\n    \"image\",\n    \"data\",\n    \"confirmedAt\",\n    \"createdAt\",\n    \"updatedAt\",\n    \"mode\",\n    \"userId\",\n    \"userUuid\",\n    \"tenantId\",\n    \"isConfirmed\",\n  ];\n  for (const prop of propsToDefine) {\n    if (prop === \"update\") return;\n    store.user[prop] = idTokenPayload[prop];\n  }\n}\n\n/**\n * Remove all user information\n */\nexport function unsetUser() {\n  for (const attr in store.user) {\n    if (typeof store.user[attr] !== \"function\") {\n      delete store.user[attr];\n    }\n  }\n}\n\n/**\n * Export the store.user object with the update method added\n */\nexport const user = store.user;\n","import axios from \"axios\";\nimport { store } from \"./store.js\";\n\n// Replace multiple slashes // with single slash / (except in the protocol)\nfunction reduceSlashes(str) {\n  return str.replace(/([^:]\\/)\\/+/g, \"$1\");\n}\n\n/**\n * Perform a GET request\n * @param {String} path\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function get(path, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.get(url, options);\n}\n\n/**\n * Perform a POST request\n * @param {String} path\n * @param {Object} payload\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function post(path, payload, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.post(url, payload, options);\n}\n\n/**\n * Perform a PUT request\n * @param {String} path\n * @param {Object} payload\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function put(path, payload, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.put(url, payload, options);\n}\n\nexport default {\n  get,\n  post,\n  put,\n};\n","import Cookies from \"js-cookie\";\nimport { store } from \"./store.js\";\nimport { setTokensFromCookies, unsetTokens } from \"./tokens.js\";\n\n/**\n * Set a cookie value based on the given options.\n * @param {String} value\n * @param {Object} options\n * @param {String} type\n */\nexport function setCookie(value, options, type) {\n  const cookieName = `${type}.${store.tenantId}`;\n  options = options || {\n    secure: store.mode === \"live\",\n    sameSite: \"Lax\",\n  };\n  if (type === \"refresh\") {\n    options.sameSite = \"Strict\";\n  }\n  Cookies.set(cookieName, value, options);\n}\n\n/**\n * Remove a cookie by name, regardless of its cookie setting(s).\n * @param {String} name\n */\nfunction removeCookie(name) {\n  // Define all possible path and domain combinations\n  let paths, domains;\n  try {\n    const path = window.location.pathname;\n    const hostname = window.location.hostname;\n    const hostnameParts = hostname.split(\".\");\n    const primaryDomain = hostnameParts.slice(-2).join(\".\");\n    paths = [undefined, path, \"/\"];\n    domains = [\n      undefined,\n      hostname,\n      `.${hostname}`,\n      primaryDomain,\n      `.${primaryDomain}`,\n    ];\n  } catch (err) {\n    paths = [undefined, \"/\"];\n    domains = [undefined];\n  }\n\n  // Iterate over paths and domains, and remove cookies if present\n  paths.map((path) => {\n    domains.map((domain) => {\n      const options = {};\n      if (domain) options.domain = domain;\n      if (path) options.path = path;\n      Cookies.remove(name, options);\n    });\n  });\n}\n\n/**\n * Remove all auth cookies (access, id, refresh).\n */\nexport function removeAllCookies() {\n  removeCookie(store.tokens.accessTokenName);\n  removeCookie(store.tokens.idTokenName);\n  removeCookie(store.tokens.refreshTokenName);\n  unsetTokens();\n}\n\n/**\n * Set the cookies from a tokens object, and add to the local store.\n * @param {Object} tokens\n */\nexport function setCookiesAndTokens(tokens) {\n  setCookie(tokens.access.value, tokens.access.cookieOptions, \"access\");\n  setCookie(tokens.id.value, tokens.id.cookieOptions, \"id\");\n  if (tokens.refresh && tokens.refresh.value) {\n    setCookie(tokens.refresh.value, tokens.refresh.cookieOptions, \"refresh\");\n  }\n  setTokensFromCookies();\n}\n","import Cookies from \"js-cookie\";\nimport { store } from \"./store.js\";\nimport { setUser, unsetUser } from \"./user.js\";\nimport { refresh } from \"./refresh.js\";\nimport { isJwtLocallyValid } from \"./utils.js\";\n\nstore.tokens = store.tokens || {};\nstore.tokens.refresh = refresh;\n\nexport function setTokenNames() {\n  store.tokens = store.tokens || {};\n  store.tokens.accessTokenName = `access.${store.tenantId}`;\n  store.tokens.idTokenName = `id.${store.tenantId}`;\n  store.tokens.refreshTokenName = `refresh.${store.tenantId}`;\n}\n\n/**\n * Set and then return the access token\n */\nexport function accessToken() {\n  store.tokens.accessToken = Cookies.get(store.tokens.accessTokenName);\n  return store.tokens.accessToken;\n}\n\n/**\n * Set and then return the ID token\n */\nexport function idToken() {\n  store.tokens.idToken = Cookies.get(store.tokens.idTokenName);\n  return store.tokens.idToken;\n}\n\n/**\n * Define the store token values from the cookie values.\n */\nexport function setTokensFromCookies() {\n  const tokenNames = [\"access\", \"id\", \"refresh\"];\n  tokenNames.map((tokenName) => {\n    try {\n      const token = Cookies.get(store.tokens[`${tokenName}TokenName`]);\n      store.tokens[`${tokenName}Token`] = token;\n\n      // Set the user object whenever the ID token is set\n      if (tokenName === \"id\" && token) {\n        setUser();\n      }\n    } catch (error) {\n      console.warn(`Problem setting ${tokenName} token.`);\n    }\n  });\n}\n\n/**\n * Set the store token values to undefined\n */\nexport function unsetTokens() {\n  store.tokens.accessToken = undefined;\n  store.tokens.idToken = undefined;\n  store.tokens.refreshToken = undefined;\n  unsetUser();\n}\n\n/**\n * Client-side check:\n * Determine whether the access token is present and unexpired\n * @returns {Boolean}\n */\nexport function isAccessTokenLocallyValid() {\n  return isJwtLocallyValid(store.tokens.accessToken);\n}\n\n/**\n * Client-side check:\n * Determine whether the refresh token is present and unexpired\n * @returns {Boolean}\n */\nexport function isRefreshTokenLocallyValid() {\n  return isJwtLocallyValid(store.tokens.refreshToken);\n}\n\n/**\n * Export the store.tokens object\n */\nexport const tokens = store.tokens;\n\n// NOTE Commenting this out 6/11/21 because the packages it relies on (jsonwebtoken & jwks-rsa)\n// both cause a lot of bloat. If we want to verify tokens, this is a nice way to do it, but\n// we need to find libraries designed for the browser instead of node.\n/**\n * Verify the provided token\n * @param {String} token\n * @returns {Promise<void>} The provided token has been verified if `verifyToken` resolves without error\n */\n// export async function verifyToken(token) {\n//   if (!token) throw new Error(\"Missing token\");\n\n//   let publicKey;\n//   try {\n//     const decodedToken = jwt.decode(token, { complete: true });\n//     if (!decodedToken.header || !decodedToken.header.kid) {\n//       throw new Error(\"Token kid not defined\");\n//     }\n\n//     const client = new JwksClient({\n//       jwksUri: `${apiUrl}tenants/${store.tenantId}/jwks/${store.mode}`,\n//       requestHeaders: { origin: window.location.origin },\n//     });\n\n//     const key = await client.getSigningKey(decodedToken.header.kid);\n//     publicKey = key.getPublicKey();\n//   } catch (error) {\n//     throw error;\n//   }\n\n//   if (!publicKey) {\n//     throw new Error(\"Public key not found\");\n//   }\n\n//   try {\n//     jwt.verify(token, publicKey);\n//   } catch (error) {\n//     throw new Error(\"Token verification failed\");\n//   }\n\n//   return Promise.resolve();\n// }\n","import Cookies from \"js-cookie\";\nimport { get } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\n// import { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Refresh the access and ID tokens\n * - When in test mode, uses the basic refresh method\n * - For tenants without a custom SSL certificate, uses the basic refresh method\n * - For tenants with a custom SSL certificate and in live mode, uses the httpOnly refresh method\n * @returns {Promise}\n */\nexport async function refresh() {\n  try {\n    await basicRefresh();\n  } catch (error) {\n    console.warn(`Refresh failed: ${error.message}`);\n  }\n}\n\n/**\n * Use a regular (non-httpOnly) cookie to refresh the access and ID tokens.\n *\n * The basic refresh method is used automatically in test mode and in live\n * mode whenever an SSL certificate has not been set up.\n */\nasync function basicRefresh() {\n  const refreshToken = Cookies.get(store.tokens.refreshTokenName);\n  try {\n    const { data, status } = await get(`/auth/refresh`, {\n      headers: {\n        authorization: `Bearer ${refreshToken}`,\n      },\n    });\n    if (status !== 200) {\n      throw new Error(data.message || \"Problem with request\");\n    }\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      return data;\n    } else {\n      throw new Error(\"Problem setting cookies\");\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n// TODO re-enable httpOnly refresh method once new endpoints are stable [06/15/21]\n/**\n *\n * The httpOnly refresh method is only available for tenants with configured\n * SSL certificates while in live mode.\n */\n// async function httpOnlyRefresh() {\n//   const iframe = getIframe();\n//   if (!iframe) return;\n//   return postMessageAsPromise({\n//     type: \"refresh\",\n//     tenantId: store.tenantId,\n//   });\n// }\n\n/**\n * Use a sessionId and nonce to set the iframe refresh token\n * @param {String} sessionId\n * @param {String} nonce\n * @returns {Promise}\n */\nexport async function exchange({ sessionId, nonce }) {\n  return;\n\n  // TODO re-enable httpOnly exchange method once new endpoints are stable [06/15/21]\n  // --------------------------\n  // const iframe = getIframe();\n  // if (!iframe) return;\n  // return postMessageAsPromise({\n  //   type: \"exchange\",\n  //   tenantId: store.tenantId,\n  //   payload: {\n  //     sessionId,\n  //     nonce,\n  //   },\n  // });\n}\n","import {\n  isAccessTokenLocallyValid,\n  isRefreshTokenLocallyValid,\n} from \"./tokens.js\";\nimport { refresh } from \"./refresh.js\";\n\n/**\n * Determine whether a user is logged in by checking their\n * JWT access token and, if invalid, refreshing it and checking\n * again.\n * @returns {Promise<Boolean>}\n */\nasync function getIsLoggedIn() {\n  try {\n    // If the access token is locally valid, return true\n    if (isAccessTokenLocallyValid()) {\n      return true;\n    }\n\n    // If the refresh token is locally invalid, return false\n    if (!isRefreshTokenLocallyValid()) {\n      return false;\n    }\n\n    // Attempt to refresh the access token\n    await refresh();\n\n    // The access token should now be valid\n    return isAccessTokenLocallyValid();\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Return detailed information about the current session.\n * @returns {Promise<Object>}\n */\nexport async function getSession() {\n  const isLoggedIn = await getIsLoggedIn();\n  return { isLoggedIn };\n}\n","import { get } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\nimport { getSession } from \"./session.js\";\n\n/**\n * Get the value of a query attribute, e.g. ?attr=value\n * @param {String} attrName\n */\nexport function getQueryAttr(attrName) {\n  if (\n    typeof window !== \"object\" ||\n    typeof window.location !== \"object\" ||\n    !window.location.href ||\n    window.location.href.indexOf(`${attrName}=`) < 0\n  ) {\n    return;\n  }\n  return decodeURIComponent(\n    window.location.href.split(`${attrName}=`)[1].split(\"&\")[0]\n  );\n}\n\n/**\n * Redirect the browser based on explicit redirect input path, or the API response\n * @property {String|Boolean} redirect A path to redirect to, or false to not redirect\n * @property {Object} data The response object from the API\n * @returns\n */\nexport const handleRedirect = ({ redirect, data }) => {\n  if (redirect === false) return;\n  const path = redirect || getQueryAttr(\"redirect\") || data.redirectTo || \"/\";\n  redirectToPath(path);\n};\n\n/**\n * If the access token is valid, redirect the browser to the\n * tenant's After-login path.\n */\nexport async function redirectIfLoggedIn({ redirect } = {}) {\n  const { isLoggedIn } = await getSession();\n  if (!isLoggedIn) {\n    return removeAllCookies();\n  }\n\n  // Redirect to a provided path (check options first, then url querystring)\n  if (redirect) {\n    return redirectToPath(redirect);\n  } else if (getQueryAttr(\"redirect\")) {\n    return redirectToPath(getQueryAttr(\"redirect\"));\n  }\n\n  // If no path was provided, look up the path and then redirect there\n  try {\n    const { data } = await get(`/self`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    if (data.tenant && data.tenant.loginRedirectPath) {\n      redirectToPath(data.tenant.loginRedirectPath);\n    }\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\n/**\n * If the access token is invalid, redirect the browser to the\n * provided path.\n */\nexport async function redirectIfLoggedOut({ redirect } = {}) {\n  // If the user is logged in, return without doing anything\n  const { isLoggedIn } = await getSession();\n  if (isLoggedIn) {\n    return;\n  }\n\n  // Remove all cookies\n  removeAllCookies();\n\n  // Redirect to a provided path (check options first, then url querystring)\n  if (redirect) {\n    return redirectToPath(redirect);\n  } else if (getQueryAttr(\"redirect\")) {\n    return redirectToPath(getQueryAttr(\"redirect\"));\n  }\n\n  // If no redirect path was provided, do not redirect\n  return;\n}\n\n/**\n * Redirect to path portion of a URL.\n */\nexport function redirectToPath(pathOrUrl) {\n  // Return if no pathOrUrl, or if SSR or mobile\n  if (\n    !pathOrUrl ||\n    typeof document !== \"object\" ||\n    typeof window !== \"object\"\n  ) {\n    return;\n  }\n  try {\n    document && window;\n  } catch (error) {\n    return;\n  }\n\n  // Perform hard redirect\n  const el = document.createElement(\"a\");\n  el.href = pathOrUrl;\n  let path = `${el.pathname}${el.hash}${el.search}`;\n  if (el.pathname !== window.location.pathname) {\n    window.location.assign(path);\n  }\n}\n","import { post, put } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { getQueryAttr, handleRedirect } from \"./url.js\";\nimport { throwFormattedError } from \"./utils.js\";\nimport { exchange } from \"./refresh.js\";\n\n/**\n * Register a new user with username, name, email, and password.\n * Redirect the browser after successful signup based on the redirectTo value returned.\n * @param {String} username\n * @param {String} name\n * @param {String} email\n * @param {String} password\n * @param {Object} userData - alias for the user.data object, since \"data\" is used in the response\n * @param {String} redirect - do not redirect if false, or redirect to a specific path\n */\nexport async function signupWithPassword({\n  username,\n  name,\n  email,\n  password,\n  userData,\n  redirect,\n} = {}) {\n  try {\n    const { data } = await post(`/auth/create`, {\n      tenantId: store.tenantId,\n      username,\n      name,\n      email,\n      password,\n      data: userData,\n    });\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    } else {\n      throw new Error(\"Please try again.\");\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log a user in with email/username and password.\n * Redirect the browser after successful login based on the redirectTo value returned.\n * @param {Object} options\n */\nexport async function loginWithPassword({\n  email,\n  username,\n  emailOrUsername,\n  password,\n  redirect,\n}) {\n  try {\n    const { data } = await post(`/auth/basic`, {\n      tenantId: store.tenantId,\n      emailOrUsername: email || username || emailOrUsername,\n      password,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Please try again.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Send a password reset link to the provided email.\n * @param {String} email\n */\nexport async function sendResetLink(email) {\n  try {\n    const { data } = await post(`/auth/reset/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Set a user's password with their link credentials or JWT access token.\n *\n * If no method is provided, the order is:\n * - Check for link credentials; then\n * - Check for a JWT access token first\n *\n * @property {String} method (optional) \"link\" or \"jwt\"\n * @property {String} password\n * @property {String} existingPassword\n * @property {String} uuid\n * @property {String} token\n * @property {String} redirect\n * @returns\n */\nexport async function updatePassword({\n  method,\n  password,\n  existingPassword,\n  uuid,\n  token,\n  redirect,\n}) {\n  switch (method) {\n    // Allow for explicit setting of method\n    case \"link\":\n      return updatePasswordWithLink({ uuid, token, password, redirect });\n    case \"jwt\":\n      return updatePasswordWithJwt({ password, existingPassword });\n    default:\n      // Default (no method provided) is to look for link credentials first, then JWT access token\n      token = token || getQueryAttr(\"token\");\n      uuid = uuid || getQueryAttr(\"uuid\");\n      if (uuid && token) {\n        return updatePasswordWithLink({ uuid, token, password, redirect });\n      } else if (store.tokens.accessToken) {\n        return updatePasswordWithJwt({ password, existingPassword });\n      } else {\n        throw new Error(\n          \"updatePassword() was called without link credentials (token & uuid) or a JWT access token.\"\n        );\n      }\n  }\n}\n\nexport const resetPassword = updatePassword;\n\nexport async function updatePasswordWithLink({\n  uuid,\n  token,\n  password,\n  redirect,\n}) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) throw new Error(\"Missing token or uuid\");\n    const { data } = await put(`/auth/reset`, {\n      tenantId: store.tenantId,\n      uuid,\n      token,\n      password,\n    });\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      handleRedirect({ redirect, data });\n      return data;\n    } else {\n      throw new Error(\n        \"There was a problem resetting your password. Please try again.\"\n      );\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\nexport async function updatePasswordWithJwt({ password, existingPassword }) {\n  try {\n    if (!store.tokens.accessToken) {\n      throw new Error(\n        `updatePassword({ method: \"jwt\" }) was called without a JWT access token.`\n      );\n    }\n\n    const { data } = await put(\n      `/auth/basic`,\n      {\n        tenantId: store.tenantId,\n        password,\n        existingPassword,\n      },\n      {\n        headers: {\n          Authorization: `Bearer ${store.tokens.accessToken}`,\n        },\n      }\n    );\n\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { store } from \"./store.js\";\nimport { getQueryAttr } from \"./url.js\";\n\nexport function getProviderLink({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  if (!store.tenantId) throw new Error(\"Missing tenantId\");\n\n  let url = `${store.baseUrl}auth/${provider}/login?tenant_id=${store.tenantId}&origin=${window.location.origin}`;\n\n  let redirectTo = redirect || getQueryAttr(\"redirect\");\n  if (redirect === false) {\n    redirectTo = typeof document === \"object\" && document.location.pathname;\n  }\n  if (redirectTo) {\n    url += `&redirect=${encodeURIComponent(redirectTo)}`;\n  }\n\n  return url;\n}\n\n/**\n * Log in or register a user via SSO provider.\n * Redirect the browser after successful authentication and 302 redirect from server.\n * @param {String} provider Name of SSO provider\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport function signonWithSso({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  const url = getProviderLink({ provider, redirect });\n  window.location.assign(url);\n}\n","import { post, put } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { getQueryAttr, handleRedirect } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Log a user in with a token/uuid combo passed into the function or\n * in the URL querystring. ?token=...&uuid=...\n * @param {String} token\n * @param {UUID} uuid\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithLink({ token, uuid, redirect } = {}) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) return;\n\n    const { data } = await put(\"/auth/link\", {\n      token,\n      uuid,\n      tenantId: store.tenantId,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Problem logging in.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Send a login link to the provided email.\n * @param {String} email\n */\nexport async function sendLoginLink(email) {\n  try {\n    const { data } = await post(`/auth/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Create or update a user and send them a link to log in.\n * @param {Object} inputs\n */\nexport async function sendPasswordlessLink({\n  email,\n  name,\n  username,\n  userData,\n  options,\n}) {\n  try {\n    const { data } = await post(`/auth/link`, {\n      email,\n      name,\n      username,\n      data: userData,\n      options,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { post, put } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { handleRedirect } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Verify that proper identifier is available for the channel\n * @property {String} channel \"sms\" or \"email\"\n * @property {String} phoneNumber\n * @property {String} email\n */\nfunction enforceChannel({ channel, phoneNumber, email }) {\n  if (channel !== \"sms\" && channel !== \"email\") {\n    throw new Error(\"Invalid channel\");\n  }\n  if (channel === \"sms\" && !phoneNumber) {\n    throw new Error(`SMS verification code requires \"phoneNumber\"`);\n  } else if (channel === \"email\" && !email) {\n    throw new Error(`Email verification code requires \"email\"`);\n  }\n}\n\n/**\n * Send a verification code to the provided email address or phone number.\n * @property {String} channel \"sms\" (default) or \"email\"\n * @property {String} phoneNumber\n * @property {String} email\n * @property {String} name\n * @property {String} username\n * @property {Object} data\n */\nexport async function sendVerificationCode({\n  channel = \"sms\",\n  phoneNumber,\n  email,\n  name,\n  username,\n  data,\n}) {\n  try {\n    enforceChannel({\n      channel,\n      phoneNumber,\n      email,\n    });\n\n    const { data: res } = await post(`/auth/code`, {\n      channel,\n      email,\n      phoneNumber,\n      name,\n      username,\n      data,\n      tenantId: store.tenantId,\n    });\n    return res;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log a user in with a token/uuid combo passed into the function or\n * in the URL querystring. ?token=...&uuid=...\n * @param {String} token\n * @param {UUID} uuid\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithVerificationCode({\n  channel,\n  verificationCode,\n  email,\n  phoneNumber,\n  redirect,\n} = {}) {\n  try {\n    enforceChannel({\n      channel,\n      phoneNumber,\n      email,\n    });\n\n    const { data } = await put(`/auth/code`, {\n      channel,\n      verificationCode,\n      email,\n      phoneNumber,\n      tenantId: store.tenantId,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Problem logging in.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { get, post } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { handleRedirect } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Log a user in with a TOTP authenticator code or a TOTP backup code,\n * plus an identifier for the user (e.g. userId, userUuid, or email)\n *\n * @property {String} totpCode \"123456\"\n * @property {String} backupCode \"aaaaa-bbbbb\"\n * @property {Integer} userId\n * @property {String} userUuid\n * @property {String} emailOrUsername\n * @property {String} email\n * @property {String} username\n * @property {String} phoneNumber\n * @property {String|Boolean} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithTotp({\n  totpCode,\n  backupCode,\n  userId,\n  userUuid,\n  emailOrUsername,\n  email,\n  username,\n  phoneNumber,\n  redirect,\n} = {}) {\n  try {\n    if (!totpCode && !backupCode) return;\n\n    const { data } = await post(`/auth/totp`, {\n      totpCode,\n      backupCode,\n      userId,\n      userUuid,\n      emailOrUsername,\n      email,\n      username,\n      phoneNumber,\n      tenantId: store.tenantId,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      handleRedirect({ redirect, data });\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Problem logging in.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\nexport async function getTotp() {\n  try {\n    if (!store.tokens.accessToken) {\n      throw new Error(`getTotp() was called without a JWT access token.`);\n    }\n\n    const { data } = await get(`/auth/totp`, {\n      headers: {\n        Authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { get } from \"./api.js\";\nimport { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\nimport { setTokensFromCookies } from \"./tokens.js\";\nimport { handleRedirect } from \"./url\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Log a user out and redirect to the logout path.\n */\nexport async function logout({ method, redirect } = {}) {\n  if (method === \"saml\") {\n    return completeSamlLogout();\n  }\n  if (!store.tokens.accessToken) {\n    return removeAllCookies();\n  }\n\n  try {\n    const { data } = await get(`/auth/logout`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    removeAllCookies();\n    handleRedirect({ redirect, data });\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\nasync function completeSamlLogout() {\n  if (!store.tokens.accessToken) {\n    throw new Error(\"Please log in to authorize your logout request.\");\n  }\n\n  try {\n    const { data } = await get(`/auth/saml/idp/token`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    window.location.assign(\n      `${store.baseUrl}auth/saml/idp/logout?tenant_id=${store.tenantId}&token=${data.token}&uuid=${store.user.userUuid}`\n    );\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n// TODO re-enable exchange method once new endpoints are stable [06/15/21]\n// --------------------------\n// const iframe = getIframe();\n// if (!iframe) return;\n// try {\n//   const { data } = await postMessageAsPromise({\n//     type: \"logout\",\n//     tenantId: store.tenantId,\n//   });\n//   removeAllCookies();\n//   setTokensFromCookies();\n//   handleRedirect({ redirect, data });\n// } catch (error) {\n//   removeAllCookies();\n//   redirectToPath(\"/\");\n// }\n","export const apiUrl = `https://api.userfront.com/v0/`;\n\nexport const privateIPRegex =\n  /((^127\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.))\\d{1,3}\\.\\d{1,3}/g;\n","import { get } from \"./api.js\";\nimport { privateIPRegex } from \"./constants.js\";\nimport { store } from \"./store.js\";\n\n/**\n * Global mode object\n */\nexport const mode = {\n  value: \"live\",\n  reason: undefined,\n  setMode,\n};\n\nsetModeSync();\n\n/**\n * Determine whether a hostname is in test mode.\n * @param {String} hn\n */\nexport function isTestHostname(hn) {\n  try {\n    const hostname = hn || window.location.hostname;\n    return !!(hostname.match(/localhost/g) || hostname.match(privateIPRegex));\n  } catch (err) {\n    return true;\n  }\n}\n\nexport function isHttps() {\n  try {\n    return window.location.protocol === \"https:\";\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Define the mode of operation (live or test)\n */\nexport async function setMode() {\n  try {\n    const { data } = await get(`/tenants/${store.tenantId}/mode`);\n    mode.value = data.mode || \"test\";\n    mode.reason = getReason(mode.value);\n    store.mode = mode.value;\n  } catch (err) {\n    mode.value = \"test\";\n    store.mode = mode.value;\n  }\n}\n\n/**\n * Estimate the mode without making an API call\n */\nexport function setModeSync() {\n  const modeValue = isTestHostname() || !isHttps() ? \"test\" : \"live\";\n  mode.value = modeValue;\n  mode.reason = getReason(modeValue);\n  store.mode = modeValue;\n}\n\n/**\n * Set the reason for the mode\n * - http\n * - domain\n */\nfunction getReason(mode) {\n  try {\n    if (mode === \"live\") {\n      return \"domain\";\n    }\n    if (window.location.protocol === \"http:\") {\n      return \"http\";\n    } else if (window.location.protocol !== \"https:\") {\n      return \"protocol\";\n    } else {\n      return \"domain\";\n    }\n  } catch (error) {}\n}\n","/**\n * user methods are refactored into a separate file to avoid a circular dependency\n * between Userfront.refresh() [which requires setUser()]\n * and Userfront.user.update() [which requires refresh()].\n */\nimport { put } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { refresh } from \"./refresh.js\";\nimport { getTotp } from \"./totp.js\";\nimport { getJwtPayload } from \"./utils.js\";\nimport { updatePassword } from \"./password.js\";\n\n/**\n * Update the user record on Userfront\n * @param {Object} payload User properties to update e.g. { name: 'John Doe' }\n */\nexport async function update(payload) {\n  if (!payload || Object.keys(payload).length < 1) {\n    return console.warn(\"Missing user properties to update\");\n  }\n\n  // Make request to update the user\n  await put(`/self`, payload, {\n    headers: {\n      authorization: `Bearer ${store.tokens.accessToken}`,\n    },\n  });\n\n  // Refresh the access and ID tokens, and set the store.user object from the ID token\n  await refresh();\n\n  return store.user;\n}\n\n/**\n * Determine whether the access token has a given role\n * @param {String} roleName\n * @param {Object} options\n * @returns {Boolean}\n */\nexport function hasRole(roleName, { tenantId } = {}) {\n  try {\n    if (!store.tokens.accessToken || !store.tenantId) {\n      return false;\n    }\n    const { authorization } = getJwtPayload(store.tokens.accessToken);\n    if (!authorization) {\n      return false;\n    }\n    tenantId = tenantId || store.tenantId;\n    if (!authorization[tenantId] || !authorization[tenantId].roles) {\n      return false;\n    }\n    return authorization[tenantId].roles.indexOf(roleName) > -1;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Add the methods to the store.user object\n */\nstore.user.update = update;\nstore.user.hasRole = hasRole;\nstore.user.updatePassword = updatePassword;\nstore.user.getTotp = getTotp;\n","import axios from \"axios\";\nimport { store } from \"./store.js\";\nimport {\n  tokens,\n  accessToken,\n  idToken,\n  setTokensFromCookies,\n  setTokenNames,\n} from \"./tokens\";\nimport { getSession } from \"./session\";\nimport { redirectIfLoggedIn, redirectIfLoggedOut } from \"./url.js\";\nimport { signup } from \"./signup.js\";\nimport { login } from \"./login.js\";\nimport { updatePassword, resetPassword, sendResetLink } from \"./password.js\";\nimport { sendLoginLink } from \"./link.js\";\nimport { sendVerificationCode } from \"./verificationCode\";\nimport { logout } from \"./logout.js\";\nimport { mode, setMode, setModeSync } from \"./mode.js\";\n// import { setIframe } from \"./iframe.js\";\nimport { user } from \"./user.js\";\nimport \"./user.methods.js\";\nimport { refresh } from \"./refresh.js\";\nimport { apiUrl } from \"./constants.js\";\n\nlet initCallbacks = [];\n\n/**\n * Initialize the Userfront library.\n * @param {String} tenantId\n */\nfunction init(tenantId, opts = {}) {\n  if (!tenantId) return console.warn(\"Userfront initialized without tenantId\");\n\n  store.tenantId = tenantId;\n\n  store.baseUrl = opts.baseUrl || apiUrl;\n  if (!store.baseUrl.endsWith(\"/\")) {\n    store.baseUrl += \"/\";\n  }\n\n  if (opts.domain) {\n    store.domain = opts.domain;\n    const url = `https://${store.domain}`;\n    axios.defaults.headers.common[\"x-application-id\"] = url;\n    axios.defaults.headers.common[\"x-origin\"] = url;\n  }\n\n  setTokenNames();\n  // setIframe(); // TODO re-enable when iframe is needed\n  setTokensFromCookies();\n  setModeSync();\n\n  try {\n    if (initCallbacks.length > 0) {\n      initCallbacks.forEach((cb) => {\n        if (!cb || typeof cb !== \"function\") return;\n        cb({ tenantId });\n      });\n    }\n    initCallbacks = [];\n  } catch (error) {}\n}\n\n/**\n * Add a callback function to be called upon Userfront.init()\n * @param {Function} cb\n */\nfunction addInitCallback(cb) {\n  if (!cb || typeof cb !== \"function\") return;\n  initCallbacks.push(cb);\n}\n\n/**\n\n * Register a window-level event called \"urlchanged\" that will fire\n * whenever the browser URL changes.\n */\nlet isRegistered = false;\nfunction registerUrlChangedEventListener() {\n  if (isRegistered) return;\n  isRegistered = true;\n  try {\n    history.pushState = ((f) =>\n      function pushState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"pushstate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.pushState);\n\n    history.replaceState = ((f) =>\n      function replaceState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"replacestate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.replaceState);\n\n    window.addEventListener(\"popstate\", () => {\n      window.dispatchEvent(new Event(\"urlchanged\"));\n    });\n  } catch (error) {}\n}\n\n/**\n * EXPORTS\n */\n\nexport default {\n  // index\n  addInitCallback,\n  init,\n  registerUrlChangedEventListener,\n\n  //logout\n  logout,\n\n  // mode\n  mode,\n  setMode,\n\n  // refresh\n  refresh: (a, b, c) => {\n    try {\n      console.warn(\n        \"Userfront.refresh() is deprecated and will be removed. Please use Userfront.tokens.refresh() instead.\"\n      );\n    } catch (error) {}\n    return refresh(a, b, c);\n  },\n\n  // signon\n  login,\n  resetPassword,\n  updatePassword,\n  sendLoginLink,\n  sendResetLink,\n  sendVerificationCode,\n  signup,\n\n  // store\n  store,\n\n  // tokens\n  tokens,\n  accessToken,\n  idToken,\n\n  // session\n  getSession,\n\n  // url\n  redirectIfLoggedIn,\n  redirectIfLoggedOut,\n\n  // user\n  user,\n\n  // utils\n};\n","import { loginWithPassword } from \"./password.js\";\nimport { loginWithLink, sendPasswordlessLink } from \"./link.js\";\nimport { signonWithSso } from \"./sso.js\";\nimport { loginWithTotp } from \"./totp.js\";\nimport { loginWithVerificationCode } from \"./verificationCode.js\";\nimport { completeSamlLogin } from \"./saml.js\";\n\n/**\n * Log a user in via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {String} method\n * @param {Number} userId\n * @param {String} userUuid\n * @param {String} email\n * @param {String} username\n * @param {String} emailOrUsername\n * @param {String} phoneNumber\n * @param {String} password\n * @param {String} token\n * @param {String} uuid\n * @param {String} totpCode\n * @param {String} backupCode\n * @param {String} channel \"sms\" or \"email\"\n * @param {String} verificationCode\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function login({\n  method,\n  // User identifiers\n  userId,\n  userUuid,\n  email,\n  username,\n  emailOrUsername,\n  phoneNumber,\n  // Password\n  password,\n  // Link\n  token,\n  uuid,\n  // Totp\n  totpCode,\n  backupCode,\n  // Verification code\n  channel,\n  verificationCode,\n  // Other\n  redirect,\n} = {}) {\n  if (!method) {\n    throw new Error('Userfront.login called without \"method\" property.');\n  }\n  switch (method) {\n    case \"apple\":\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return signonWithSso({ provider: method, redirect });\n    case \"password\":\n      return loginWithPassword({\n        email,\n        username,\n        emailOrUsername,\n        password,\n        redirect,\n      });\n    case \"passwordless\":\n      return sendPasswordlessLink({ email });\n    case \"link\":\n      return loginWithLink({ token, uuid, redirect });\n    case \"totp\":\n      return loginWithTotp({\n        totpCode,\n        backupCode,\n        userId,\n        userUuid,\n        emailOrUsername,\n        email,\n        username,\n        phoneNumber,\n        redirect,\n      });\n    case \"verificationCode\":\n      return loginWithVerificationCode({\n        channel,\n        email,\n        phoneNumber,\n        verificationCode,\n        redirect,\n      });\n    case \"saml\":\n      return completeSamlLogin();\n    default:\n      throw new Error('Userfront.login called with invalid \"method\" property.');\n  }\n}\n","import { get } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\nexport async function completeSamlLogin() {\n  try {\n    if (!store.tokens.accessToken) {\n      return console.warn(\"Cannot complete SAML login without access token\");\n    }\n\n    const { data } = await get(`/auth/saml/idp/token`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    window.location.assign(\n      `${store.baseUrl}auth/saml/idp/login?tenant_id=${store.tenantId}&token=${data.token}&uuid=${store.user.userUuid}`\n    );\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { signupWithPassword } from \"./password.js\";\nimport { signonWithSso } from \"./sso.js\";\nimport { sendPasswordlessLink } from \"./link.js\";\nimport { sendVerificationCode } from \"./verificationCode.js\";\n\n/**\n * Register a user via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {String} method\n * @param {String} email\n * @param {String} username\n * @param {String} phoneNumber\n * @param {String} name\n * @param {Object} data - Object for custom user fields\n * @param {String} password\n * @param {String} channel \"sms\" or \"email\"\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function signup({\n  method,\n  email,\n  username,\n  phoneNumber,\n  name,\n  data,\n  password,\n  channel,\n  redirect,\n} = {}) {\n  if (!method) {\n    throw new Error('Userfront.signup called without \"method\" property.');\n  }\n  switch (method) {\n    case \"apple\":\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return signonWithSso({ provider: method, redirect });\n    case \"password\":\n      return signupWithPassword({\n        username,\n        name,\n        email,\n        password,\n        userData: data,\n        redirect,\n      });\n    case \"passwordless\":\n      return sendPasswordlessLink({ email, name, username, userData: data });\n    case \"verificationCode\":\n      return sendVerificationCode({\n        channel,\n        email,\n        phoneNumber,\n        name,\n        username,\n        data,\n      });\n    default:\n      throw new Error(\n        'Userfront.signup called with invalid \"method\" property.'\n      );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}